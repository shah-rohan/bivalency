---
title: "bivalency_analysis"
author: "Rohan Shah"
date: "7/15/2021"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

This R Markdown file is meant to streamline the analysis of the bivalency data and keep it organized in one place. Different types of analyses will be in different sections with explanations as to why those are important. This section will contain only data loading and functions that are necessary for downstream analyses.

## Data loading

This chunk loads in both the HMD data and the bulk RNA-seq data, as well as the tidyverse and sleuth libraries.

```{r data_loader, message = FALSE, warning = FALSE}

library(topGO)
library(GO.db)
library(biomaRt)
library(tidyverse)
library(sleuth)

load("rdata/data_loaded.RData")
load("rdata/sleuth_loaded_bivalency_bulk-rna-seq.RData")

#Redo the HMDs for 0-400bp about the TSS

naive_hmd = data.frame(Gene = naive$k4$Gene)
naive_hmd$k4 = naive$k4 %>% select(X0:X400) %>% rowMeans
naive_hmd$k9 = naive$k9 %>% select(X0:X400) %>% rowMeans
naive_hmd$k27 = naive$k27 %>% select(X0:X400) %>% rowMeans
naive_hmd$cis = naive$cis %>% select(X0:X400) %>% rowMeans
naive_hmd$trans = naive$trans %>% select(X0:X400) %>% rowMeans
naive_hmd$Gene = as.character(naive_hmd$Gene)

primed_hmd = data.frame(Gene = primed$k4$Gene)
primed_hmd$k4 = primed$k4 %>% select(X0:X400) %>% rowMeans
primed_hmd$k9 = primed$k9 %>% select(X0:X400) %>% rowMeans
primed_hmd$k27 = primed$k27 %>% select(X0:X400) %>% rowMeans
primed_hmd$cis = primed$cis %>% select(X0:X400) %>% rowMeans
primed_hmd$trans = primed$trans %>% select(X0:X400) %>% rowMeans
primed_hmd$Gene = as.character(primed_hmd$Gene)

npc_hmd = data.frame(Gene = npc$k4$Gene)
npc_hmd$k4 = npc$k4 %>% select(X0:X400) %>% rowMeans
npc_hmd$k9 = npc$k9 %>% select(X0:X400) %>% rowMeans
npc_hmd$k27 = npc$k27 %>% select(X0:X400) %>% rowMeans
npc_hmd$cis = npc$cis %>% select(X0:X400) %>% rowMeans
npc_hmd$trans = npc$trans %>% select(X0:X400) %>% rowMeans
npc_hmd$Gene = as.character(npc_hmd$Gene)

hmds = list()
hmds[["naive"]] = naive_hmd
hmds[["primed"]] = primed_hmd
hmds[["npc"]] = npc_hmd

rm(naive_hmd, primed_hmd, npc_hmd)

tss_range = seq(-3, 3, by = 0.05)

sleuth_objs = list()
sleuth_objs[["all"]] = so_all
sleuth_objs[["naive_npc"]] = so_naive_npc
sleuth_objs[["naive_primed"]] = so_naive_primed
sleuth_objs[["primed_npc"]] = so_primed_npc

rm(so_all, so_naive_npc, so_naive_primed, so_primed_npc)

rm(metadata_naive_npc, metadata_naive_primed, metadata_primed_npc)

```

The next chunk loads in functions to make metagenes.

```{r metagene_functions, message = FALSE, warning = FALSE}

get_biv_genes = function(dataset, threshold){
  genes = (dataset %>% filter(trans > threshold))$Gene
  return(genes)
}

metagene = function(dataset, range, genes){
  dataset_names = names(dataset)
  summ_df = data.frame(dist = range)
  
  for (i in dataset_names){
    summ_df[,i] = as.numeric(dataset[[i]] %>% filter(Gene %in% genes) %>% dplyr::select(-1) %>% summarize(across(.fns = mean)))
  }
  
  return(summ_df)
}

metagene_plot = function(summ_df, ylims = NA, title = NA){
  summ_plt = summ_df %>% gather("mod", "hmd", -dist)
  plot_summary = ggplot(data = summ_plt, aes(x = dist, y = hmd, color = mod)) + geom_line() + theme_classic()
  
  if (!is.na(ylims)){ plot_summary = plot_summary + scale_y_continuous(limits = ylims) }
  
  if (!is.na(title)){ plot_summary = plot_summary + ggtitle(title) }
  
  print(plot_summary)
}

```

# First-Pass HMD Metagene Analysis

First, we have to have a sense of how bivalency exists at all genes. To do this, we will plot metagenes of all genes for all samples.

```{r all_genes_meta}

metagene_plot(metagene(naive, tss_range, consensusGenes), ylims = c(0,80), title = "Naive mESCs")
metagene_plot(metagene(primed, tss_range, consensusGenes), ylims = c(0,80), title = "Primed mESCs")
metagene_plot(metagene(npc, tss_range, consensusGenes), ylims = c(0,80), title = "NPCs")

```

We observe that there is a significant amount of bivalency (especially trans bivalency) at all genes from naive, primed, and NPC samples. Importantly, it seems that bivalency actually *increases* over time rather than decreasing. This is interesting. My next step is to identify the average amount of bivalency in each of these samples -- and that of all other modifications, while I'm at it.

```{r all_genes_avgs, message = FALSE, warning = FALSE}

hmd_summary_precursor = hmds[["naive"]] %>% mutate(sample = "naive") %>% select(sample, k4:trans)
hmd_summary_precursor = rbind(hmd_summary_precursor, (hmds[["primed"]] %>% mutate(sample = "primed") %>% select(sample, k4:trans)))
hmd_summary_precursor = rbind(hmd_summary_precursor, (hmds[["npc"]] %>% mutate(sample = "npc") %>% select(sample, k4:trans)))

hmd_summary_all_genes = hmd_summary_precursor %>% group_by(sample) %>% summarize(across(.fns = mean))
print("HMD Summary Mean")
print(hmd_summary_all_genes)

hmd_summary_all_genes = hmd_summary_precursor %>% group_by(sample) %>% summarize(across(.fns = median))
print("HMD Summary Median")
print(hmd_summary_all_genes)
rm(hmd_summary_precursor, hmd_summary_all_genes)

```

Both by mean and median, we see that bivalency again increases from naive to primed to npc, with median trans HMDs of approximately 20%, 40%, and 30%, respectively. This means it will be somewhat difficult to identify genes that are truly "bivalent," so we're goign to go with initial thresholds of 10%, 25%, and 50%. We will load these all into lists for the sake of ease just to make it easier to handle them in the future.

```{r bivalent_thresholding, message = FALSE, warning = FALSE}

bivalent_genes_10 = list()
bivalent_genes_25 = list()
bivalent_genes_50 = list()

bivalent_genes_10[["naive"]] = get_biv_genes(hmds[["naive"]], 10)
bivalent_genes_25[["naive"]] = get_biv_genes(hmds[["naive"]], 25)
bivalent_genes_50[["naive"]] = get_biv_genes(hmds[["naive"]], 50)

bivalent_genes_10[["primed"]] = get_biv_genes(hmds[["primed"]], 10)
bivalent_genes_25[["primed"]] = get_biv_genes(hmds[["primed"]], 25)
bivalent_genes_50[["primed"]] = get_biv_genes(hmds[["primed"]], 50)

bivalent_genes_10[["npc"]] = get_biv_genes(hmds[["npc"]], 10)
bivalent_genes_25[["npc"]] = get_biv_genes(hmds[["npc"]], 25)
bivalent_genes_50[["npc"]] = get_biv_genes(hmds[["npc"]], 50)

```

As expected, the proportion of genes with the listed amount of bivalency decreases as we increase the threshold from 10% to 25% to 50%. We now wish to watch the bivalent genes by each threshold in naive cells over the course of differentiation.

```{r metagenes_naive_bivalent_tracking}

metagene_plot(metagene(naive, tss_range, bivalent_genes_10[["naive"]]), title = "Naive cells at genes with trans bivalent >10% in naive")
metagene_plot(metagene(primed, tss_range, bivalent_genes_10[["naive"]]), title = "Primed cells at genes with trans bivalent >10% in naive")
metagene_plot(metagene(npc, tss_range, bivalent_genes_10[["naive"]]), title = "NPC cells at genes with trans bivalent >10% in naive")

metagene_plot(metagene(naive, tss_range, bivalent_genes_25[["naive"]]), title = "Naive cells at genes with trans bivalent >25% in naive")
metagene_plot(metagene(primed, tss_range, bivalent_genes_25[["naive"]]), title = "Primed cells at genes with trans bivalent >25% in naive")
metagene_plot(metagene(npc, tss_range, bivalent_genes_25[["naive"]]), title = "NPC cells at genes with trans bivalent >25% in naive")

metagene_plot(metagene(naive, tss_range, bivalent_genes_50[["naive"]]), title = "Naive cells at genes with trans bivalent >50% in naive")
metagene_plot(metagene(primed, tss_range, bivalent_genes_50[["naive"]]), title = "Primed cells at genes with trans bivalent >50% in naive")
metagene_plot(metagene(npc, tss_range, bivalent_genes_50[["naive"]]), title = "NPC cells at genes with trans bivalent >50% in naive")

```

Basically, no matter how we call it, bivalent genes seem to broadly stay bivalent.

## Dominance sectioning

Let's see if sectioning this by K27 dominant bivalency or K4 dominant bivalency in the naive dataset helps at all.

```{r naive_dominance_sectioning}

naive_dominance = list()
hmds[["naive"]] = hmds[["naive"]] %>% mutate(logratio = log(k27+1) - log(k4+1))
naive_dominance[["k27"]] = (hmds[["naive"]] %>% filter(trans > 25) %>% filter(logratio > 1))$Gene
naive_dominance[["k4"]] = (hmds[["naive"]] %>% filter(trans > 25) %>% filter(logratio < -1))$Gene
naive_dominance[["mid"]] = (hmds[["naive"]] %>% filter(trans > 25) %>% filter(logratio <= 1 & logratio >= -1))$Gene

```

Overall, we see that with an $e^1$ ratio threshold (logratio 1), there are 1728 K27 dominant genes, 6335 K4 dominant genes, and 7704 neutral genes with a bivalency threshold of 25%. Of course, we now want to do metagene analysis.

```{r naive_dominance_metagene}

metagene_plot(metagene(naive, tss_range, naive_dominance[["k27"]]), title = "Naive cells at genes with trans bivalent >25% and K27 dominance in naive")
metagene_plot(metagene(primed, tss_range, naive_dominance[["k27"]]), title = "Primed cells at genes with trans bivalent >25% and K27 dominance in naive")
metagene_plot(metagene(npc, tss_range, naive_dominance[["k27"]]), title = "NPC cells at genes with trans bivalent >25% and K27 dominance in naive")

metagene_plot(metagene(naive, tss_range, naive_dominance[["k4"]]), title = "Naive cells at genes with trans bivalent >25% and k4 dominance in naive")
metagene_plot(metagene(primed, tss_range, naive_dominance[["k4"]]), title = "Primed cells at genes with trans bivalent >25% and k4 dominance in naive")
metagene_plot(metagene(npc, tss_range, naive_dominance[["k4"]]), title = "NPC cells at genes with trans bivalent >25% and k4 dominance in naive")

metagene_plot(metagene(naive, tss_range, naive_dominance[["mid"]]), title = "Naive cells at genes with trans bivalent >25% and mid dominance in naive")
metagene_plot(metagene(primed, tss_range, naive_dominance[["mid"]]), title = "Primed cells at genes with trans bivalent >25% and mid dominance in naive")
metagene_plot(metagene(npc, tss_range, naive_dominance[["mid"]]), title = "NPC cells at genes with trans bivalent >25% and mid dominance in naive")

```

Overwhelmingly, it again seems that across these bivalency dominance classes, bivalent genes remain bivalent.

# Gene Ontology Setup

My next goal will be to conduct metagene analysis on differnet gene ontologies. The goal here will be to load up the gene ontology files and accessions so that I don't have to download it again in the future.

```{r gene_ontology_setup}

if (!file.exists("rdata/go_terms.RData")){
  ensembl = biomaRt::useMart("ENSEMBL_MART_ENSEMBL", dataset = "mmusculus_gene_ensembl")
  attributes = biomaRt::listAttributes(ensembl)
  filters = biomaRt::listFilters(ensembl)
  
  go_refseq_mrna = biomaRt::getBM(attributes = c('refseq_mrna', 'ensembl_gene_id', 'external_gene_name', 'go_id'), filters = 'with_refseq_mrna', values = TRUE, mart = ensembl)
  
  go_refseq_ncrna = biomaRt::getBM(attributes = c('refseq_ncrna', 'ensembl_gene_id', 'external_gene_name', 'go_id'), filters = c('with_refseq_mrna', 'with_refseq_ncrna'), values = list(FALSE, TRUE), mart = ensembl)
  
  colnames(go_refseq_mrna) = c('refseq_id', 'ensembl_gene_id', 'external_gene_name', 'go_id')
  colnames(go_refseq_ncrna) = c('refseq_id', 'ensembl_gene_id', 'external_gene_name', 'go_id')
  refseq_ensembl_external_go = rbind(go_refseq_mrna, go_refseq_ncrna) %>% filter(refseq_id != "") %>% filter(go_id != "")
  
  refseq_with_go = refseq_ensembl_external_go$refseq_id %>% unique
  ensembl_with_go = refseq_ensembl_external_go$ensembl_gene_id %>% unique
  genename_with_go = (refseq_ensembl_external_go %>% filter(external_gene_name != ""))$external_gene_name %>% unique
  
  rm(ensembl, attributes, filters, go_refseq_mrna, go_refseq_ncrna)
  save.image("rdata/go_terms.RData")
} else {
  load("rdata/go_terms.RData")
}

```

We now have GO ids for Refseq, Ensembl, and external gene names in M. musculus. The next thing to do is to assemble lists of the GO terms for each class of genes that we will be interested in.

First, we will want to get GO terms and their offspring for developmental processes, embryo development, and maintenance of pluripotency. Then, we will examine the metabolic processes. As a negative control, so to speak, we will also pull out terms for immune system processes. Finally, we will get GO terms for neurodevelopmental processes, as these genes should be "turned on" over differentiation to NPCs.

```{r go_offspring}

go_ids = list()

go_ids[["developmental_processes"]] = c(GO.db::GOBPOFFSPRING[["GO:0032502"]], "GO:0032502")
go_ids[["embryo_development_ids"]] = c(GO.db::GOBPOFFSPRING[["GO:0009790"]], "GO:0009790")
go_ids[["maintenance_pluripotency"]] = c(GO.db::GOBPOFFSPRING[["GO:0019827"]], "GO:0019827")

go_ids[["metabolic_processes"]] = c(GO.db::GOBPOFFSPRING[["GO:0008152"]], "GO:0008152")

go_ids[["immune_system"]] = c(GO.db::GOBPOFFSPRING[["GO:0002376"]], "GO:0002376")

go_ids[["neuron_differentiation"]] = c(GO.db::GOBPOFFSPRING[["GO:0030182"]], "GO:0030182")

```

All told, we now have GO term IDs for each of our classes of interest stored in the list go_ids.

# Sectioning Metagenes with Gene Ontology

We will now use the different gene ontology terms we have just identified to create metagene plots across different GO term classes.

```{r go_metagenes}

for (go_term in names(go_ids))
{
  overlapgenes = (refseq_ensembl_external_go %>% filter(go_id %in% go_ids[[go_term]] & refseq_id %in% bivalent_genes_25[["naive"]]))$refseq_id
  
  count_genes = length(overlapgenes)
  
  metagene_plot(metagene(naive, tss_range, overlapgenes), title = paste0("Naive cells at naive 25% bivalent genes HMD in GO term ", go_term, " (", count_genes, " genes)"))
  metagene_plot(metagene(primed, tss_range, overlapgenes), title = paste0("Primed cells at naive 25% bivalent genes HMD in GO term ", go_term, " (", count_genes, " genes)"))
  metagene_plot(metagene(npc, tss_range, overlapgenes), title = paste0("NPC cells at naive 25% bivalent genes HMD in GO term ", go_term, " (", count_genes, " genes)"))
}

```

Across the different GO term classes, bivalent genes remain bivalent. 

# RNA-seq First-Pass Analysis

We have three RNA-seq datasets, which we have already aligned against the Refseq cDNA for mm10 using Kallisto and loaded into Sleuth. These are contained in sleuth_objs.

First, we will look at the data by PCA.

```{r pca_bulk_rna}

plot_pca(sleuth_objs$all, color_by = "cell_type")
plot_pca(sleuth_objs$naive_npc, color_by = "rep")
plot_pca(sleuth_objs$naive_primed, color_by = "rep")
plot_pca(sleuth_objs$primed_npc, color_by = "rep")

```

PCA looks fine, samples separate as expected without huge batch effects except with primed to NPC. We'll correct for replicate there but will otherwise just use a naive comparison.

First, we will compare naive to NPC, then naive to primed, then finally primed to NPC.

```{r diff_exp, message = FALSE, warning = FALSE}

if (!file.exists("rdata/sleuth_analysis.RData")){
  sleuth_table_gene = list()

  sleuth_objs$naive_npc = sleuth_fit(sleuth_objs$naive_npc, ~1, 'naive')
  sleuth_objs$naive_npc = sleuth_fit(sleuth_objs$naive_npc, ~cell_type, 'cell_type')
  sleuth_objs$naive_npc = sleuth_lrt(sleuth_objs$naive_npc, 'naive', 'cell_type')
  
  sleuth_table_gene[["naive_npc"]] = sleuth_results(sleuth_objs$naive_npc, 'naive:cell_type', 'lrt', show_all = FALSE, pval_aggregate = FALSE) %>% mutate(refseq_id = str_replace(target_id, "([A-Za-z0-9_]*)\\.[0-9]*", "\\1")) 
  
  sleuth_objs$naive_primed = sleuth_fit(sleuth_objs$naive_primed, ~1, 'naive')
  sleuth_objs$naive_primed = sleuth_fit(sleuth_objs$naive_primed, ~cell_type, 'cell_type')
  sleuth_objs$naive_primed = sleuth_lrt(sleuth_objs$naive_primed, 'naive', 'cell_type')
  
  sleuth_table_gene[["naive_primed"]] = sleuth_results(sleuth_objs$naive_primed, 'naive:cell_type', 'lrt', show_all = FALSE, pval_aggregate = FALSE) %>% mutate(refseq_id = str_replace(target_id, "([A-Za-z0-9_]*)\\.[0-9]*", "\\1")) 
  
  sleuth_objs$primed_npc = sleuth_fit(sleuth_objs$primed_npc, ~1, 'naive')
  sleuth_objs$primed_npc = sleuth_fit(sleuth_objs$primed_npc, ~rep, 'rep')
  sleuth_objs$primed_npc = sleuth_fit(sleuth_objs$primed_npc, ~cell_type, 'cell_type')
  sleuth_objs$primed_npc = sleuth_fit(sleuth_objs$primed_npc, ~rep+cell_type, 'full')
  sleuth_objs$primed_npc = sleuth_lrt(sleuth_objs$primed_npc, 'naive', 'cell_type')
  sleuth_objs$primed_npc = sleuth_lrt(sleuth_objs$primed_npc, 'rep', 'full')
  
  sleuth_table_gene[["primed_npc"]] = sleuth_results(sleuth_objs$primed_npc, 'rep:full', 'lrt', show_all = FALSE, pval_aggregate = FALSE) %>% mutate(refseq_id = str_replace(target_id, "([A-Za-z0-9_]*)\\.[0-9]*", "\\1"))
  
  save.image("rdata/sleuth_analysis.RData")
} else{
  load("rdata/sleuth_analysis.RData")
}

```

We see that there are several thousand genes that are differentially expressed in all these conditions: 19450/51998 from naive to NPC, 17835/50800 from naive to primed, and 9908/50126 from primed to NPC.

We also want to be able to get our average gene expression for each gene.

```{r average_gene_expression, message = FALSE, warning = FALSE}

gene_expression = sleuth_objs$all$obs_norm %>% separate(sample, c("cell_type", "rep"), sep = "_RNA_rep") %>% group_by(target_id, cell_type) %>% select(target_id, cell_type, tpm) %>% summarize(across(.fns = mean)) %>% ungroup %>% spread(key = cell_type, value = tpm)
  
gene_expression = gene_expression %>% data.frame %>% mutate(refseq_id = str_replace(target_id, "([A-Za-z0-9_]*)\\.[0-9]*", "\\1")) %>% select(target_id, refseq_id, naive = mESC_with2i, primed = mESC_no2i, npc = NPC)

```

We must also identify upregulated and downregulated genes

```{r upregulated_downregulated}

upregulated_genes = list()
downregulated_genes = list()
nonregulated_genes = list()

upregulated_genes$naive_npc = (sleuth_table_gene$naive_npc %>% filter(qval <= 0.05) %>% inner_join(gene_expression, by = "refseq_id") %>% filter(npc > naive))$refseq_id
downregulated_genes$naive_npc = (sleuth_table_gene$naive_npc %>% filter(qval <= 0.05) %>% inner_join(gene_expression, by = "refseq_id") %>% filter(npc < naive))$refseq_id
nonregulated_genes$naive_npc = (sleuth_table_gene$naive_npc %>% filter(qval > 0.05))$refseq_id

upregulated_genes$naive_primed = (sleuth_table_gene$naive_primed %>% filter(qval <= 0.05) %>% inner_join(gene_expression, by = "refseq_id") %>% filter(primed > naive))$refseq_id
downregulated_genes$naive_primed = (sleuth_table_gene$naive_primed %>% filter(qval <= 0.05) %>% inner_join(gene_expression, by = "refseq_id") %>% filter(primed < naive))$refseq_id
nonregulated_genes$naive_primed = (sleuth_table_gene$naive_primed %>% filter(qval > 0.05))$refseq_id

upregulated_genes$primed_npc = (sleuth_table_gene$primed_npc %>% filter(qval <= 0.05) %>% inner_join(gene_expression, by = "refseq_id") %>% filter(npc > primed))$refseq_id
downregulated_genes$primed_npc = (sleuth_table_gene$primed_npc %>% filter(qval <= 0.05) %>% inner_join(gene_expression, by = "refseq_id") %>% filter(npc < primed))$refseq_id
nonregulated_genes$primed_npc = (sleuth_table_gene$primed_npc %>% filter(qval > 0.05))$refseq_id

```

# Integrating RNA-seq and HMD Metagene Analysis

Having the above gene expression matrix, I want to examine the way in which gene expression changes across these different datasets from naive to NPC.

## Violin plots of gene expression

First thing to do is to get the gene expression of the genes overall.

```{r gene_expression_violin}

violin_df = gene_expression %>% select(refseq_id:npc) %>% mutate(across(.cols = naive:npc, .fns = ~log10(.+.0001))) %>% gather(key = "cell_type", value = "log10_tpm", -refseq_id)
violin_df$cell_type = factor(violin_df$cell_type, levels = c('naive', 'primed', 'npc'), ordered = TRUE)

violin_plt = ggplot(data = violin_df, aes(x = cell_type, y = log10_tpm, fill = cell_type)) + geom_violin() +  stat_summary(fun=mean, geom="point", shape=23, size=2, fill = "black") + theme_classic() + geom_boxplot(fill = "white", width = 0.1) + scale_fill_manual(values = c("firebrick2", "royalblue2", "green3")) + labs(title = "Gene expression at all genes in naive mESCs")
print(violin_plt)

rm(violin_df, violin_plt)

```

Next, we plot gene expression of bivalent genes in naive cells.

```{r gene_expression_naive_bivalent}

violin_df = gene_expression %>% filter(refseq_id %in% bivalent_genes_25$naive) %>% select(refseq_id:npc) %>% mutate(across(.cols = naive:npc, .fns = ~log10(.+.0001))) %>% gather(key = "cell_type", value = "log10_tpm", -refseq_id)
violin_df$cell_type = factor(violin_df$cell_type, levels = c('naive', 'primed', 'npc'), ordered = TRUE)

violin_plt = ggplot(data = violin_df, aes(x = cell_type, y = log10_tpm, fill = cell_type)) + geom_violin() +  stat_summary(fun=mean, geom="point", shape=23, size=2, fill = "black") + theme_classic() + geom_boxplot(fill = "white", width = 0.1) + scale_fill_manual(values = c("firebrick2", "royalblue2", "green3")) + labs(title = "Gene expression at genes with >25% bivalency in naive mESCs")
print(violin_plt)

rm(violin_df, violin_plt)

```

We see only subtle changes at best. Let us now section by K27 or K4 dominance.

```{r dominance_bivalent_gene_expression}

violin_df = gene_expression %>% filter(refseq_id %in% naive_dominance$k27) %>% select(refseq_id:npc) %>% mutate(across(.cols = naive:npc, .fns = ~log10(.+.0001))) %>% gather(key = "cell_type", value = "log10_tpm", -refseq_id)
violin_df$cell_type = factor(violin_df$cell_type, levels = c('naive', 'primed', 'npc'), ordered = TRUE)

violin_plt = ggplot(data = violin_df, aes(x = cell_type, y = log10_tpm, fill = cell_type)) + geom_violin() +  stat_summary(fun=mean, geom="point", shape=23, size=2, fill = "black") + theme_classic() + geom_boxplot(fill = "white", width = 0.1) + scale_fill_manual(values = c("firebrick2", "royalblue2", "green3")) + labs(title = "Gene expression at K27 dominant genes in naive mESCs")
print(violin_plt)

rm(violin_df, violin_plt)

violin_df = gene_expression %>% filter(refseq_id %in% naive_dominance$k4) %>% select(refseq_id:npc) %>% mutate(across(.cols = naive:npc, .fns = ~log10(.+.0001))) %>% gather(key = "cell_type", value = "log10_tpm", -refseq_id)
violin_df$cell_type = factor(violin_df$cell_type, levels = c('naive', 'primed', 'npc'), ordered = TRUE)

violin_plt = ggplot(data = violin_df, aes(x = cell_type, y = log10_tpm, fill = cell_type)) + geom_violin() +  stat_summary(fun=mean, geom="point", shape=23, size=2, fill = "black") + theme_classic() + geom_boxplot(fill = "white", width = 0.1) + scale_fill_manual(values = c("firebrick2", "royalblue2", "green3")) + labs(title = "Gene expression at K4 dominant genes in naive mESCs")
print(violin_plt)

rm(violin_df, violin_plt)

violin_df = gene_expression %>% filter(refseq_id %in% naive_dominance$mid) %>% select(refseq_id:npc) %>% mutate(across(.cols = naive:npc, .fns = ~log10(.+.0001))) %>% gather(key = "cell_type", value = "log10_tpm", -refseq_id)
violin_df$cell_type = factor(violin_df$cell_type, levels = c('naive', 'primed', 'npc'), ordered = TRUE)

violin_plt = ggplot(data = violin_df, aes(x = cell_type, y = log10_tpm, fill = cell_type)) + geom_violin() +  stat_summary(fun=mean, geom="point", shape=23, size=2, fill = "black") + theme_classic() + geom_boxplot(fill = "white", width = 0.1) + scale_fill_manual(values = c("firebrick2", "royalblue2", "green3")) + labs(title = "Gene expression at mid dominant genes in naive mESCs")
print(violin_plt)

rm(violin_df, violin_plt)

```

The other thing that we can do here is to bin the naive mESC bivalent genes by gene expression, then track those subsets of genes across the differentiation pathway.

```{r section_by_gene_expression}

for (i in 1:5)
{
  gene_expression_bivalent = gene_expression %>% filter(refseq_id %in% bivalent_genes_25$naive)
  countup = floor(length(gene_expression_bivalent$naive)/5)
  violin_df = gene_expression_bivalent %>% arrange(desc(naive)) %>%  slice((countup*(i-1)):(countup*i - 1)) %>% select(refseq_id:npc) %>% mutate(across(.cols = naive:npc, .fns = ~log10(.+.0001))) %>% gather(key = "cell_type", value = "log10_tpm", -refseq_id)
  violin_df$cell_type = factor(violin_df$cell_type, levels = c('naive', 'primed', 'npc'), ordered = TRUE)
  
  violin_plt = ggplot(data = violin_df, aes(x = cell_type, y = log10_tpm, fill = cell_type)) + geom_violin() +  stat_summary(fun=mean, geom="point", shape=23, size=2, fill = "black") + theme_classic() + geom_boxplot(fill = "white", width = 0.1) + scale_fill_manual(values = c("firebrick2", "royalblue2", "green3")) + labs(title = paste0("Gene expression at bivalent genes in naive mESCs, naive expression quintile ", i))
  print(violin_plt)
}

rm(gene_expression_bivalent, countup, violin_df, violin_plt)

```

## Metaprofiles by gene expression

The other obvious thing is to look at upregulated genes, downregulated genes, and insignificantly changed genes to look at bivalency metaprofiles there.

```{r metaprofiles_upreg_downreg}

metagene_plot(metagene(naive, tss_range, upregulated_genes$naive_npc), title = paste0("Naive cells at genes upregulated from naive to NPC (", length(upregulated_genes$naive_npc), " genes)"))
metagene_plot(metagene(primed, tss_range, upregulated_genes$naive_npc), title = paste0("Primed cells at genes upregulated from naive to NPC (", length(upregulated_genes$naive_npc), " genes)"))
metagene_plot(metagene(npc, tss_range, upregulated_genes$naive_npc), title = paste0("NPC cells at genes upregulated from naive to NPC (", length(upregulated_genes$naive_npc), " genes)"))

metagene_plot(metagene(naive, tss_range, downregulated_genes$naive_npc), title = paste0("Naive cells at genes downregulated from naive to NPC (", length(downregulated_genes$naive_npc), " genes)"))
metagene_plot(metagene(primed, tss_range, downregulated_genes$naive_npc), title = paste0("Primed cells at genes downregulated from naive to NPC (", length(downregulated_genes$naive_npc), " genes)"))
metagene_plot(metagene(npc, tss_range, downregulated_genes$naive_npc), title = paste0("NPC cells at genes downregulated from naive to NPC (", length(downregulated_genes$naive_npc), " genes)"))

metagene_plot(metagene(naive, tss_range, nonregulated_genes$naive_npc), title = paste0("Naive cells at genes nonregulated from naive to NPC (", length(nonregulated_genes$naive_npc), " genes)"))
metagene_plot(metagene(primed, tss_range, nonregulated_genes$naive_npc), title = paste0("Primed cells at genes nonregulated from naive to NPC (", length(nonregulated_genes$naive_npc), " genes)"))
metagene_plot(metagene(npc, tss_range, nonregulated_genes$naive_npc), title = paste0("NPC cells at genes nonregulated from naive to NPC (", length(nonregulated_genes$naive_npc), " genes)"))

```

Minor differences in magnitude aside, there is basically no difference between the bivalency profiles of upregulated and downregulated genes.

# Gene ontology and bivalency classes

We can now move on to running gene ontology on our different bivalency classes. We will run these by Ensembl gene IDs. First order of business is to set up our analysis by preparing the data.

```{r gene_ontology_prep, message = FALSE, warning = FALSE}

if (!file.exists("go_struct.RData")){
  ensembl_dominance = list()
  ensembl_dominance$k27 = (refseq_ensembl_external_go %>% filter(refseq_id %in% naive_dominance$k27) %>% filter(ensembl_gene_id %in% ensembl_with_go))$ensembl_gene_id %>% unique
  ensembl_dominance$k4 = (refseq_ensembl_external_go %>% filter(refseq_id %in% naive_dominance$k4) %>% filter(ensembl_gene_id %in% ensembl_with_go))$ensembl_gene_id %>% unique
  ensembl_dominance$mid = (refseq_ensembl_external_go %>% filter(refseq_id %in% naive_dominance$mid) %>% filter(ensembl_gene_id %in% ensembl_with_go))$ensembl_gene_id %>% unique
  
  gene_2_go = unstack((refseq_ensembl_external_go %>% filter(ensembl_gene_id %in% ensembl_with_go))[,c(4,2)])
  
  genelists_ontology = list()
  genelists_ontology$k27 = factor(as.integer(ensembl_with_go %in% ensembl_dominance$k27))
  names(genelists_ontology$k27) = ensembl_with_go
  genelists_ontology$k4 = factor(as.integer(ensembl_with_go %in% ensembl_dominance$k4))
  names(genelists_ontology$k4) = ensembl_with_go
  genelists_ontology$mid = factor(as.integer(ensembl_with_go %in% ensembl_dominance$mid))
  names(genelists_ontology$mid) = ensembl_with_go
  
  godata = list()
  godata$k27 = new('topGOdata', ontology = 'BP', allGenes = genelists_ontology$k27, annot = annFUN.gene2GO, gene2GO = gene_2_go)
  godata$k4 = new('topGOdata', ontology = 'BP', allGenes = genelists_ontology$k4, annot = annFUN.gene2GO, gene2GO = gene_2_go)
  godata$mid = new('topGOdata', ontology = 'BP', allGenes = genelists_ontology$mid, annot = annFUN.gene2GO, gene2GO = gene_2_go)
  save.image("go_struct.RData")
} else {
  load("go_struct.RData")
}

```

Having set that up, we will now define a function so that we can run gene ontology analyses and test for significance more efficiently.

```{r gene_ontology_functions, message = FALSE, warning = FALSE}

testGO = function(GOdata, algo = "classic"){
  fisher_result = runTest(GOdata, algorithm = algo, statistic = "fisher")
  allGO = usedGO(GOdata)
  all_res = GenTable(GOdata, Fisher = fisher_result, orderBy = 'Fisher', topNodes = length(allGO))
  p.adj=round(p.adjust(all_res$Fisher,method="BH"),digits = 4)
  p.adj[is.na(p.adj)] = 0
  all_res_final=cbind(all_res,p.adj)
  all_res_final=all_res_final[order(all_res_final$p.adj),]
  return(all_res_final)
}

```

We valswill now conduct GO analysis on the datasets described above.

```{r gene_ontology_dominance_runner}

go_classic_tables = list()
go_classic_tables$k27 = testGO(godata$k27)
go_classic_tables$k4 = testGO(godata$k4)
go_classic_tables$mid = testGO(godata$mid)

```

I don't know what to do here -- I guess pull out some of the terms that we looked at before?

```{r gene_ontology_terms_pvals, message = FALSE, warning = FALSE}

go_term_pvals = data.frame(GO.ID = c("GO:0032502", "GO:0009790", "GO:0019827", "GO:0030182", "GO:0008152", "GO:0002376"))
go_term_pvals = go_term_pvals %>% inner_join(go_classic_tables$k27, by = "GO.ID") %>% select(GO.ID, Term, k27 = p.adj)
go_term_pvals = go_term_pvals %>% inner_join(go_classic_tables$k4, by = "GO.ID") %>% select(GO.ID, Term = Term.x, k27, k4 = p.adj)
go_term_pvals = go_term_pvals %>% inner_join(go_classic_tables$mid, by = "GO.ID") %>% select(GO.ID, Term = Term.x, k27, k4, mid = p.adj)

print(go_term_pvals)

```

# Reverse feature search

We haven't found any good features that are uniquely associated with bivalency, so I guess we're just going to go the opposite direction: look for genes that obey the classic paradigm of bivalency, then identify the features to which they belong. We will identify genes that are >25% bivalent in naive with < 10% bivalent in NPCs that are differentially expressed between the two.

```{r reverse_feature_search}

bivalent_loss = setdiff(bivalent_genes_25$naive, bivalent_genes_10$npc)
bivalent_loss_de = (sleuth_table_gene$naive_npc %>% filter(qval <= 0.05) %>% filter(refseq_id %in% bivalent_loss))$refseq_id

```

There are only 432 Refseq IDs associated with classic features of bivalency. That's kind of sad. I guess we should do metagene profiles.

```{r reverse_feature_metas}

metagene_plot(metagene(naive, tss_range, bivalent_loss_de), title = "Reverse bivalency-associated feature search, naive cells")
metagene_plot(metagene(primed, tss_range, bivalent_loss_de), title = "Reverse bivalency-associated feature search, primed cells")
metagene_plot(metagene(npc, tss_range, bivalent_loss_de), title = "Reverse bivalency-associated feature search, NPC cells")

```

That looks like shit. Let's separate by upregulated and downregulated genes.

```{r reverse_feature_updown_meta}

bivalent_loss_de_up = bivalent_loss_de[bivalent_loss_de %in% upregulated_genes$naive_npc]
bivalent_loss_de_down = bivalent_loss_de[bivalent_loss_de %in% downregulated_genes$naive_npc]

metagene_plot(metagene(naive, tss_range, bivalent_loss_de_up), title = "Reverse bivalency-associated feature search, upregulated, naive cells")
metagene_plot(metagene(primed, tss_range, bivalent_loss_de_up), title = "Reverse bivalency-associated feature search, upregulated, primed cells")
metagene_plot(metagene(npc, tss_range, bivalent_loss_de_up), title = "Reverse bivalency-associated feature search, upregulated NPC cells")

metagene_plot(metagene(naive, tss_range, bivalent_loss_de_down), title = "Reverse bivalency-associated feature search, downregulated, naive cells")
metagene_plot(metagene(primed, tss_range, bivalent_loss_de_down), title = "Reverse bivalency-associated feature search, downregulated, primed cells")
metagene_plot(metagene(npc, tss_range, bivalent_loss_de_down), title = "Reverse bivalency-associated feature search, downregulated NPC cells")

```

# Classification of genes

This is essentially asking the final question about whether bivalency is actually an example of the "histone code." We will create a classification variable to identify whether a gene is developmentally regulated.

First we will look at naive to npc, then look at primed to npc.

## Naive to NPC

```{r classifcation_setup}

hmd_diffexp_naive_npc = hmds$naive %>% inner_join(sleuth_table_gene$naive_npc, by = c("Gene" = "refseq_id")) %>% select(Gene:k27, trans, qval) %>% mutate(diffexp = ifelse(qval <= 0.05, 1, 0)) %>% mutate(diffexp = as.factor(diffexp)) %>% mutate(logk4 = log(k4+1), logk27 = log(k27+1)) %>% select(diffexp, k4, logk4, k27, logk27, k9, trans)

naive_npc_BICs = numeric()

# Trivial Model
naive_npc_BICs["trivial"] = BIC(glm(diffexp ~ 1, data = hmd_diffexp_naive_npc, family = binomial))

# K4 only
naive_npc_BICs["k4"] = BIC(glm(diffexp ~ k4, data = hmd_diffexp_naive_npc, family = binomial))

# K27 only
naive_npc_BICs["k27"] = BIC(glm(diffexp ~ k27, data = hmd_diffexp_naive_npc, family = binomial))

# K9 only
naive_npc_BICs["k9"] = BIC(glm(diffexp ~ k9, data = hmd_diffexp_naive_npc, family = binomial))

# trans only
naive_npc_BICs["trans"] = BIC(glm(diffexp ~ trans, data = hmd_diffexp_naive_npc, family = binomial))

# K4 + K27
naive_npc_BICs["k4_k27"] = BIC(glm(diffexp ~ k4 + k27, data = hmd_diffexp_naive_npc, family = binomial))

# K4 + K27 + trans
naive_npc_BICs["k4_k27_trans"] = BIC(glm(diffexp ~ k4 + k27 + trans, data = hmd_diffexp_naive_npc, family = binomial))

# K4 + K27 + log of each
naive_npc_BICs["k4_k27_logs"] = BIC(glm(diffexp ~ k4 + k27 + logk4 + logk27, data = hmd_diffexp_naive_npc, family = binomial))

# K4 + K27 + log of each + bivalency
naive_npc_BICs["k4_k27_logs_trans"] = BIC(glm(diffexp ~ k4 + k27 + logk4 + logk27 + trans, data = hmd_diffexp_naive_npc, family = binomial))

# log k4 + log k27
naive_npc_BICs["logs"] = BIC(glm(diffexp ~ logk4 + logk27, data = hmd_diffexp_naive_npc, family = binomial))

# log k4 + log k27
naive_npc_BICs["logs_trans"] = BIC(glm(diffexp ~ logk4 + logk27 + trans, data = hmd_diffexp_naive_npc, family = binomial))

print(naive_npc_BICs[order(naive_npc_BICs)])

```

On the whole, we find that the model with K4 and K27 with logs of both minimizes BIC by approximately 9.94, which is massive.

We will now show the logistic regression therein.

```{r logistic_regressions}

glm_k4_k27_logs_naive_npc = glm(diffexp ~ k4 + k27 + logk4 + logk27, data = hmd_diffexp_naive_npc, family = binomial)

hmd_diffexp_naive_npc$predicted = predict(glm_k4_k27_logs_naive_npc, newdata = hmd_diffexp_naive_npc, type = "response")
plot(x = hmd_diffexp_naive_npc$predicted, y = hmd_diffexp_naive_npc$diffexp)

glm_k4_k27_logs_naive_npc_trans = glm(diffexp ~ k4 + k27 + logk4 + logk27 + trans, data = hmd_diffexp_naive_npc, family = binomial)

hmd_diffexp_naive_npc$predicted_trans = predict(glm_k4_k27_logs_naive_npc_trans, newdata = hmd_diffexp_naive_npc, type = "response")
plot(x = hmd_diffexp_naive_npc$predicted_trans, y = hmd_diffexp_naive_npc$diffexp)

```

This is still a very crappy measure, by all accounts. But it's less crappy without trans than with (or rather, it becomes less not-crappy with trans than expected by random chance). We can get the significance estimates for all these models.

```{r logistic_regressions_summaries}

# K4, K27, log K4, log K27
summary(glm_k4_k27_logs_naive_npc)

# K4, K27, log K4, log K27, trans
summary(glm_k4_k27_logs_naive_npc_trans)

```

Of course, this should be done better. We will use training and testing data.

```{r split_data}

set.seed(1209)

sample = sample.int(n = nrow(hmd_diffexp_naive_npc), size = floor(.7*nrow(hmd_diffexp_naive_npc)), replace = F)

hmd_diffexp_naive_npc_train = hmd_diffexp_naive_npc[sample,]
hmd_diffexp_naive_npc_test = hmd_diffexp_naive_npc[-sample,]

glm_k4_k27_logs_naive_npc_train = glm(diffexp ~ k4 + k27 + logk4 + logk27, data = hmd_diffexp_naive_npc_train, family = binomial)
glm_k4_k27_logs_naive_npc_trans_train = glm(diffexp ~ k4 + k27 + logk4 + logk27 + trans, data = hmd_diffexp_naive_npc_train, family = binomial)
glm_k4_k27_logs_naive_npc_k9_train = glm(diffexp ~ k4 + k27 + logk4 + logk27 + k9, data = hmd_diffexp_naive_npc_train, family = binomial)

hmd_diffexp_naive_npc_test$predicted = predict(glm_k4_k27_logs_naive_npc_train, newdata = hmd_diffexp_naive_npc_test, type = "response")
hmd_diffexp_naive_npc_test$predicted_trans = predict(glm_k4_k27_logs_naive_npc_trans_train, newdata = hmd_diffexp_naive_npc_test, type = "response")
hmd_diffexp_naive_npc_test$predicted_k9 = predict(glm_k4_k27_logs_naive_npc_k9_train, newdata = hmd_diffexp_naive_npc_test, type = "response")

plot(x = hmd_diffexp_naive_npc_test$predicted, y = hmd_diffexp_naive_npc_test$diffexp)
plot(x = hmd_diffexp_naive_npc_test$predicted_trans, y = hmd_diffexp_naive_npc_test$diffexp)
plot(x = hmd_diffexp_naive_npc_test$predicted_k9, y = hmd_diffexp_naive_npc_test$diffexp)

hmd_diffexp_naive_npc_test = hmd_diffexp_naive_npc_test %>% mutate(predicted_dir = ifelse(predicted>0.5, 1, 0), predicted_dir_trans = ifelse(predicted_trans>0.5, 1, 0), predicted_dir_k9 = ifelse(predicted_k9>0.5, 1, 0))

mean(1==hmd_diffexp_naive_npc_test$diffexp)
mean(hmd_diffexp_naive_npc_test$predicted_dir==hmd_diffexp_naive_npc_test$diffexp)
mean(hmd_diffexp_naive_npc_test$predicted_dir_trans==hmd_diffexp_naive_npc_test$diffexp)
mean(hmd_diffexp_naive_npc_test$predicted_dir_k9==hmd_diffexp_naive_npc_test$diffexp)

```

By the trivial model where we assume everything is differentially expressed, we find that we have an accuracy rate of 51.3%. By adding in a GLM for K4, K27, log K4, and log K27, we increase accuracy rate to 56.3%. By added in trans bivalency to the GLM on top of that, we only increase to accuracy rate to 56.4%, and to an even lesser degree than if we instead added in K9.

Conclusion: bivalency does not provide us with more information about developmental staging of genes than do K4 and K27 alone.

## Primed to NPC

```{r classifcation_setup}

hmd_diffexp_primed_npc = hmds$primed %>% inner_join(sleuth_table_gene$primed_npc, by = c("Gene" = "refseq_id")) %>% select(Gene:k27, trans, qval) %>% mutate(diffexp = ifelse(qval <= 0.05, 1, 0)) %>% mutate(diffexp = as.factor(diffexp)) %>% mutate(logk4 = log(k4+1), logk27 = log(k27+1)) %>% select(diffexp, k4, logk4, k27, logk27, k9, trans)

primed_npc_BICs = numeric()

# Trivial Model
primed_npc_BICs["trivial"] = BIC(glm(diffexp ~ 1, data = hmd_diffexp_primed_npc, family = binomial))

# K4 only
primed_npc_BICs["k4"] = BIC(glm(diffexp ~ k4, data = hmd_diffexp_primed_npc, family = binomial))

# K27 only
primed_npc_BICs["k27"] = BIC(glm(diffexp ~ k27, data = hmd_diffexp_primed_npc, family = binomial))

# K9 only
primed_npc_BICs["k9"] = BIC(glm(diffexp ~ k9, data = hmd_diffexp_primed_npc, family = binomial))

# trans only
primed_npc_BICs["trans"] = BIC(glm(diffexp ~ trans, data = hmd_diffexp_primed_npc, family = binomial))

# K4 + K27
primed_npc_BICs["k4_k27"] = BIC(glm(diffexp ~ k4 + k27, data = hmd_diffexp_primed_npc, family = binomial))

# K4 + K27 + trans
primed_npc_BICs["k4_k27_trans"] = BIC(glm(diffexp ~ k4 + k27 + trans, data = hmd_diffexp_primed_npc, family = binomial))

# K4 + K27 + log of each
primed_npc_BICs["k4_k27_logs"] = BIC(glm(diffexp ~ k4 + k27 + logk4 + logk27, data = hmd_diffexp_primed_npc, family = binomial))

# K4 + K27 + log of each + bivalency
primed_npc_BICs["k4_k27_logs_trans"] = BIC(glm(diffexp ~ k4 + k27 + logk4 + logk27 + trans, data = hmd_diffexp_primed_npc, family = binomial))

# log k4 + log k27
primed_npc_BICs["logs"] = BIC(glm(diffexp ~ logk4 + logk27, data = hmd_diffexp_primed_npc, family = binomial))

# log k4 + log k27
primed_npc_BICs["logs_trans"] = BIC(glm(diffexp ~ logk4 + logk27 + trans, data = hmd_diffexp_primed_npc, family = binomial))

print(primed_npc_BICs[order(primed_npc_BICs)])

```

Here, we find that the model with logs of k4 and k27 is better than that with logs and trans by 2.55.

